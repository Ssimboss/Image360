//
//  Image360Controller.swift
//  Image360
//
//  Copyright © 2017 Andrew Simvolokov. All rights reserved.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

import UIKit
import CoreMotion

private let blackFileURL = Bundle(for: Image360Controller.self).url(forResource: "black", withExtension: "jpg")!

/// ## Image360Controller
/// This controller presentes a special view to dysplay 360° panoramic image.
public class Image360Controller: UIViewController {
    /// Image 360 view which actually dysplays 360° panoramic image.
    public var imageView: Image360View
    /// Special OpenGL controller to ouput Image360View
    private let image360GLController: Image360GLController
    /// Displays current camera position.
    private var orientationView: OrientationView

    // MARK: Inertia
    private let inertiaInterval: TimeInterval = 0.020
    /// Amount of movement parameter for inertia (weak)
    private let weakIntertiaRatio: Float = 1.0
    /// Amount of movement parameter for inertia (strong)
    private let strongIntertiaRatio: Float = 10.0

    private var inertiaRatio: Float?

    /// Inertia of pan gestures. In case inertia is enabled view of
    /// `Image360Controller` continue to rotate after pan gestures for some time.
    /// Range of value: 0...1
    public var inertia: Float {
        get {
            return _inertia
        }
        set {
            if newValue < 0 {
                _inertia = 0
            } else if newValue > 1 {
                _inertia = 1
            } else {
                _inertia = newValue
            }
        }
    }
    private var _inertia: Float = 0.1 {
        willSet {
            inertiaTimer?.invalidate()
            inertiaTimer = nil
            inertiaTimerCount = 0
        }
    }

    fileprivate var inertiaTimerCount: UInt = 0
    fileprivate var inertiaTimer: Timer?

    /// Image presented in controller at the moment. Image need to be captured by special
    /// 360° panoramic camera or generated by special software.
    public var image: UIImage? {
        get {
            return imageView.image
        }
        set {
            imageView.image = newValue
        }
    }
    
    /// Set this flag `true` to hide orientation view.
    public var isOrientationViewHidden: Bool {
        get {
            return orientationView.isHidden
        }
        set {
            orientationView.isHidden = newValue
        }
    }
    
    /// If this flag is `true` then `ImageView360`-orientation could be controled with device motions.
    public var isDeviceMotionControlEnabled: Bool {
        didSet {
            if isDeviceMotionControlEnabled && !motionManager.isDeviceMotionAvailable {
                NSLog("Image360: Device motion is not available on this device")
                isDeviceMotionControlEnabled = false
            } else if isAppear && (oldValue != isDeviceMotionControlEnabled) {
                isDeviceMotionControlEnabled ? enableDeviceMotionControl() : disableDeviceMotionControl()
            }
        }
    }
    
    /// If this flag is `true` then `ImageView360`-orientation could be controled with gestures.
    public var isGestureControlEnabled: Bool {
        didSet {
            guard oldValue != isGestureControlEnabled else {
                return
            }
            if isGestureControlEnabled {
                registerGestureRecognizers()
            } else {
                removeGestureRecognizers()
            }
        }
    }
    
    /// MARK: Motion Management
    private var motionManager = CMMotionManager()
    
    private func enableDeviceMotionControl() {
        motionManager.deviceMotionUpdateInterval = 0.07
        let queue = OperationQueue()
        motionManager.startDeviceMotionUpdates(to: queue, withHandler: deviceDidMove)
    }
    
    private func disableDeviceMotionControl() {
        motionManager.stopDeviceMotionUpdates()
    }

    public required init?(coder aDecoder: NSCoder) {
        imageView = Image360View(frame: CGRect(x: 0, y: 0, width: 512, height: 512))
        image360GLController = Image360GLController(imageView: imageView)
        let orientationView = OrientationView(frame: CGRect(x: 0.0, y: 0.0, width: 30.0, height: 30.0))
        orientationView.backgroundColor = UIColor(white: 0.5, alpha: 0.5)
        orientationView.tintColor = .white
        self.orientationView = orientationView
        isDeviceMotionControlEnabled = motionManager.isDeviceMotionAvailable
        isGestureControlEnabled = true
        super.init(coder: aDecoder)
        registerGestureRecognizers()
        imageView.touchesHandler = self
        imageView.orientationView = orientationView
        
        setBlackBackground()
        
    }

    public override func loadView() {
        super.loadView()
        addChildViewController(image360GLController)
        view.addSubview(imageView)
        image360GLController.view.frame = view.bounds
        image360GLController.view.autoresizingMask = [.flexibleWidth,.flexibleHeight]
        image360GLController.didMove(toParentViewController: self)
        
        view.addSubview(orientationView)
        orientationView.frame = CGRect(origin: CGPoint(x: view.bounds.maxX - orientationView.frame.size.width - 8,
                                                       y: view.bounds.midY - orientationView.bounds.midY),
                                       size: orientationView.frame.size)
        orientationView.autoresizingMask =  [.flexibleTopMargin, .flexibleBottomMargin, .flexibleLeftMargin]
    }

    // MARK: Appear/Disappear
    private var isAppear = false

    public override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        if let presentedImage = imageView.image {
            imageView.image = presentedImage
        }
    }

    public override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        if isDeviceMotionControlEnabled {
            enableDeviceMotionControl()
        }
        isAppear = true
    }

    public override func viewDidDisappear(_ animated: Bool) {
        imageView.unloadTextures()

        super.viewDidDisappear(animated)
        if isDeviceMotionControlEnabled {
            disableDeviceMotionControl()
        }
        isAppear = false
    }

    // MARK: Helpers
    private func setBlackBackground() {
        let data = (try? Data(contentsOf: blackFileURL))!
        let image = UIImage(data: data)!
        imageView.image = image
    }

    // MARK: Gestures
    private var panGestureRecognizer: UIPanGestureRecognizer?
    private var pinchGestureRecognizer: UIPinchGestureRecognizer?

    fileprivate var isPanning = false
    private var panPrev: CGPoint?
    private var panLastDiffX: CGFloat?
    private var panLastDiffY: CGFloat?

    /// Creates gesture recognazer instances.
    private func registerGestureRecognizers() {
        let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(panGestureHandler(recognizer:)))
        panGestureRecognizer.maximumNumberOfTouches = 1
        panGestureRecognizer.delegate = self
        imageView.addGestureRecognizer(panGestureRecognizer)
        self.panGestureRecognizer = panGestureRecognizer

        let pinchGestureRecognizer = UIPinchGestureRecognizer(target: self, action: #selector(pinchGestureHandler(recognizer:)))
        pinchGestureRecognizer.delegate = self
        imageView.addGestureRecognizer(pinchGestureRecognizer)
        self.pinchGestureRecognizer = pinchGestureRecognizer
    }
    
    /// Remove gesture recognazer instances.
    private func removeGestureRecognizers() {
        if let panGestureRecognizer = panGestureRecognizer {
            imageView.removeGestureRecognizer(panGestureRecognizer)
        }
        if let pinchGestureRecognizer = pinchGestureRecognizer {
            imageView.removeGestureRecognizer(pinchGestureRecognizer)
        }
        panGestureRecognizer = nil
        pinchGestureRecognizer = nil
    }

    /// Pinch operation compatibility handler
    /// - parameter recognizer: Recognizer object for gesture operations
    func pinchGestureHandler(recognizer: UIPinchGestureRecognizer) {
        switch recognizer.state {
        case .began:
            prevScale = 1.0
        default:
            ()
        }
        scale(ratio: recognizer.scale)
    }

    /// Pan operation compatibility handler
    /// - parameter recognizer: Recognizer object for gesture operations
    func panGestureHandler(recognizer: UIPanGestureRecognizer) {
        let cur = recognizer.translation(in: imageView)

        switch recognizer.state {
        case .ended:
            inertiaTimer?.invalidate()
            inertiaTimerCount = 0

            if inertia > 0.05 {
                inertiaTimer = Timer.scheduledTimer(timeInterval: inertiaInterval,
                                                    target: self,
                                                    selector: #selector(inertiaTimerHandler(timer:)),
                                                    userInfo: nil,
                                                    repeats: true)
            }
        default:
            if isPanning {
                panLastDiffX = cur.x - panPrev!.x
                panLastDiffY = cur.y - panPrev!.y

                panPrev = cur
                rotate(diffx: -Float(panLastDiffX!) / divideRotateX,
                       diffy: Float(panLastDiffY!) / divideRotateY)
            } else {
                isPanning = true
                panPrev = cur
            }
        }
    }

    /// Timer setting method
    /// - parameter timer: Setting target timer
    func inertiaTimerHandler(timer: Timer) {
        var diffX: Float = 0
        var diffY: Float = 0

        if inertiaTimerCount == 0 {
            inertiaRatio = inertia * 10.0
        } else if inertiaTimerCount > 150 {
            inertiaTimer?.invalidate()
            inertiaTimer = nil
            inertiaTimerCount = 0
        } else {
            diffX = Float(panLastDiffX!) * (1.0 / Float(inertiaTimerCount)) * inertiaRatio!
            diffY = Float(panLastDiffY!) * (1.0 / Float(inertiaTimerCount)) * inertiaRatio!

            rotate(diffx: -diffX / divideRotateX,
                   diffy: diffY / divideRotateY)
        }

        inertiaTimerCount += 1
    }

    // MARK: Scaling & rotation
    private var prevScale: CGFloat = 1.0
    /// Parameter for maximum width control
    private let scaleRatioTickExpansion: Float = 1.05
    /// Parameter for minimum width control
    private let scaleRatioTickReduction: Float = 0.95

    /// Zoom in/Zoom out method
    /// - parameter ratio: Zoom in/zoom out ratio
    private func scale(ratio: CGFloat) {
        if ratio < prevScale {
            imageView.setCameraFovDegree(newValue: imageView.cameraFovDegree * scaleRatioTickExpansion)
        } else {
            imageView.setCameraFovDegree(newValue: imageView.cameraFovDegree * scaleRatioTickReduction)
        }
        prevScale = ratio
    }

    /// Parameter for amount of rotation control (X axis)
    private let divideRotateX: Float = 500.0
    /// Parameter for amount of rotation control (Y axis)
    private let divideRotateY: Float = 500.0

    /// Rotation method
    /// - parameter diffx: Rotation amount (y axis)
    /// - parameter diffy: Rotation amount (xy plane)
    private func rotate(diffx: Float, diffy: Float) {
        imageView.setRotationAngleXZ(newValue: imageView.rotationAngleXZ + diffx)
        imageView.setRotationAngleY(newValue: imageView.rotationAngleY + diffy)
    }
    
    private var _lastAttitude: CMAttitude?
    /// Device Motion Updates Handler
    /// - parameter data: New data of device motion.
    /// - parameter error: Error catched by device.
    private func deviceDidMove(data: CMDeviceMotion?, error: Error?) {
        guard let data = data else {
            return
        }
        guard let lastAttitude = _lastAttitude else {
            _lastAttitude = data.attitude
            return
        }
        _lastAttitude = data.attitude.copy() as? CMAttitude
        
        data.attitude.multiply(byInverseOf: lastAttitude)
        
        let diffXZ = -Float(data.attitude.roll)
        let diffY = Float(data.attitude.pitch)
        DispatchQueue.main.async { [weak self] in
            self?.rotate(diffx: diffXZ, diffy: diffY)
        }
    }
}

// MARK: - UIGestureRecognizerDelegate
extension Image360Controller: UIGestureRecognizerDelegate {
    // UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:) handler.
    public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
        return false
    }
}

// MARK: - Image360ViewTouchesHandler
extension Image360Controller: Image360ViewTouchesHandler {
    func image360View(_ view: Image360View, touchesBegan touches: Set<UITouch>, with event: UIEvent?) {
        inertiaTimer?.invalidate()
        inertiaTimer = nil
        inertiaTimerCount = 0

        isPanning = false
    }

    func image360View(_ view: Image360View, touchesMoved touches: Set<UITouch>, with event: UIEvent?) {
    }

    func image360View(_ view: Image360View, touchesEnded touches: Set<UITouch>, with event: UIEvent?) {
    }
}
